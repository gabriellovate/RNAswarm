#!/usr/bin/env python3

"""parse_peaks.py

This script takes an annotation table, a genome file (fasta format) and one or more trns files, and returns a table with the annotation and the peak base pair for each interaction.
The annotation table must have the following columns: id,segment01,start01,end01,segment02,start02,end02

Usage:
    parse_peaks.py <input_file> <input_file>... -a <annotation_table> -g <genome> -o <output_file> [--stdout]
    parse_peaks.py <input_file> -a <annotation_table> -g <genome> -o <output_file> [--stdout]
    parse_peaks.py -h | --help

Options:
    -h --help                                 Show this screen.
    <input_file>                              The input files to process, has to be a trns file generated by segemehl.
    -a --annotation_table=<annotation_table>  The annotation table filepath.
    -g --genome=<genome>                      The genome filepath.
    -o --output=<output_file>                 The output directory.
"""

from docopt import docopt
import os
import numpy as np
import pandas as pd
import helper as hp
import trns_handler as th
import array_handler as ah

def get_peak_cell_from_annotation_table(combination_arrays, annotation, genome_dict):
    """
    Get the peak cell of the interaction matrix from the annotation table.

    Parameters
    ----------
    combination_arrays : dict
        A dictionary of arrays, with the keys being the combination of segments.

    annotation : pandas.DataFrame
        The annotation data frame.

    genome_dict : dict
        A dictionary with keys being genome segments and values being the genome sequence.

    Returns
    -------
    dict
        A dictionary of peak cells, with the keys being the combination of segments.
    """
    combination = (annotation['segment01'], annotation['segment02'])
    combination_reverse = (annotation['segment02'], annotation['segment01'])
    start01 = int(annotation['start01'])
    end01 = int(annotation['end01'])
    start02 = int(annotation['start02'])
    end02 = int(annotation['end02'])
    combination_array = combination_arrays[combination]
    if combination in combination_arrays:
        # slice the array to the region of interest
        region_of_interest = combination_array[
            start01:end01,
            start02:end02,
        ]
        # segment01_peak, segment02_peak = np.unravel_index(region_of_interest.argmax(), region_of_interest.shape)
        # value_peak = region_of_interest[segment01_peak, segment02_peak]
        # Get the peak cell
        peak_cell = np.argmax(region_of_interest)
        # Get the coordinates of the peak cell
        peak_cell_coordinates = np.unravel_index(peak_cell, region_of_interest.shape)
        # Get the value of the peak cell
        peak_cell_value = np.max(region_of_interest)
        segment01_peak = peak_cell_coordinates[0] + start01
        segment02_peak = peak_cell_coordinates[1] + start02
        # Check if the value of the cell in the peak_cell_coordinates is the same as the value of the peak cell
        # if not, raise an error
        if peak_cell_value != combination_array[segment01_peak, segment02_peak]:
            raise ValueError(
                "The value of the peak cell is not the same as the value of the cell in the peak_cell_coordinates"
                )
    elif combination_reverse in combination_arrays:
        # slice the array to the region of interest
        region_of_interest = combination_array[
            start02:end02,
            start01:end01,
        ]
        # get the peak cell
        # segment01_peak, segment02_peak = np.unravel_index(region_of_interest.argmax(), region_of_interest.shape)
        # value_peak = region_of_interest[segment01_peak, segment02_peak]
        # Get the peak cell
        peak_cell = np.argmax(region_of_interest)
        # Get the coordinates of the peak cell
        peak_cell_coordinates = np.unravel_index(peak_cell, region_of_interest.shape)
        # Get the value of the peak cell
        peak_cell_value = np.max(region_of_interest)
        segment01_peak = peak_cell_coordinates[1] + start01
        segment02_peak = peak_cell_coordinates[0] + start02
        # Check if the value of the cell in the peak_cell_coordinates is the same as the value of the peak cell
        # if not, raise an error
        if peak_cell_value != combination_array[segment01_peak, segment02_peak]:
            raise ValueError(
                "The value of the peak cell is not the same as the value of the cell in the peak_cell_coordinates"
                )
    else:
        raise ValueError("Combination not found")
    peak_dict = {
        # 'segment01_peak': segment01_peak + start01,
        # 'segment02_peak': segment02_peak + start02,
        'segment01_peak': segment01_peak,
        'segment02_peak': segment02_peak,
        'value_peak': peak_cell_value
    }
    return peak_dict


def get_peak_cell_from_daniels_table(combination_arrays, annotation, genome_dict):
    """
    Get the peak cell of the interaction matrix from daniel's annotation table.

    Parameters
    ----------
    combination_arrays : dict
        A dictionary of arrays, with the keys being the combination of segments.

    annotation : pandas.DataFrame
        The annotation dataframe.

    Returns
    -------
    dict
        A dictionary of peak cells, with the keys being the combination of segments.
    """
    combination = (annotation['aSeq'], annotation['bSeq'])
    combination_reverse = (annotation['bSeq'], annotation['aSeq'])
    transposed_annotation = negative_to_positive_strand(genome_dict, annotation['aSeq'], annotation['cai'], annotation['caj'], annotation['bSeq'], annotation['cbi'], annotation['cbj'])
    if combination in combination_arrays:
        # slice the array to the region of interest
        region_of_interest = combination_arrays[combination][
            transposed_annotation[1]:transposed_annotation[2],
            transposed_annotation[4]:transposed_annotation[5],
        ]
        # get the peak cell
        aPeak, bPeak = np.unravel_index(region_of_interest.argmax(), region_of_interest.shape)
        valuePeak = region_of_interest[aPeak, bPeak]
        # convert the peak cell to the original coordinates
        aPeak += transposed_annotation[1]
        bPeak += transposed_annotation[4]
    elif combination_reverse in combination_arrays:
        # slice the array to the region of interest
        region_of_interest = combination_arrays[combination_reverse][
            transposed_annotation[4]:transposed_annotation[5],
            transposed_annotation[1]:transposed_annotation[2],
        ]
        # get the peak cell
        bPeak, aPeak = np.unravel_index(region_of_interest.argmax(), region_of_interest.shape)
        valuePeak = region_of_interest[aPeak, bPeak]
        # convert the peak cell to the original coordinates
        aPeak += transposed_annotation[4]
        bPeak += transposed_annotation[1]
    else:
        raise ValueError("Combination not found")
    peak_dict = {
        'aPeak': positive_to_negative_strand_point(genome_dict, annotation['aSeq'], aPeak),
        'bPeak': positive_to_negative_strand_point(genome_dict, annotation['bSeq'], bPeak),
        'valuePeak': valuePeak
    }
    return peak_dict


def main():
    args = docopt(__doc__)
    input_files = args["<input_file>"]
    annotation_table = args["--annotation_table"]
    genome = args["--genome"]

    # Parse annotation table
    annotation_table = pd.read_csv(annotation_table, sep=",", header=0)

    # Parse genome file
    genome_dict = hp.parse_fasta(genome)
    combination_arrays = {}

    # Check if trns_files is a list or a single file
    if isinstance(input_files, str):
        trns_file_name = os.path.basename(trns_file)
        trns_file_name = trns_file_name.split(".")[0]

        # Create and fill combination arrays
        combination_arrays[trns_file_name] = hp.make_combination_array(genome_dict)
        th.segemehlTrans2heatmap(trns_file, combination_arrays[trns_file_name])
        merged_combination_arrays = combination_arrays

    if isinstance(input_files, list):
        for trns_file in input_files:
            # Get the name of the current trns file
            trns_file_name = os.path.basename(trns_file)
            trns_file_name = trns_file_name.split(".")[0]

            # Create and fill combination arrays
            combination_arrays[trns_file_name] = hp.make_combination_array(genome_dict)
            th.segemehlTrans2heatmap(trns_file, combination_arrays[trns_file_name])

        # Merge combination arrays
        merged_combination_arrays = ah.combine_arrays(
            combination_arrays, normalise_array=False
        )
    
    # Check the peak cell for each annotation
    peak_cell_dict = {}
    for index, row in annotation_table.iterrows():
        peak_cel = get_peak_cell_from_annotation_table(merged_combination_arrays, row, genome_dict)
        peak_cell_dict[index] = peak_cel
        # make peak cell dict into a dataframe
        peak_cell_df = pd.DataFrame.from_dict(peak_cell_dict, orient="index")

    # Merge the peak cell dataframe with the annotation table
    merged_df = pd.merge(annotation_table, peak_cell_df, left_index=True, right_index=True)

    # Check if the output directory exists, if not create it
    if not os.path.exists(args["--output"]):
        os.makedirs(args["--output"])

    # save the merged dataframe to a file inside the output directory with the naming convention: <genome_file_name>_peak_cells.csv
    if args["--stdout"]:
        print(merged_df.to_csv(sep=",", index=False))
    else:
        output_file = os.path.basename(genome)
        output_file = output_file.split(".")[0]
        output_file = args["--output"] + "/" + output_file + "_peak_cells.csv"
        merged_df.to_csv(output_file, sep=",", index=False)


if __name__ == "__main__":
    main()
