#!/usr/bin/env python

import os
import argparse

print('RNAswarm')




def run_fastp(fastq_file, output_dir):
    """
    Run fastp on a fastq file
    """
    fastp_cmd = f"fastp -i {fastq_file} -o {output_dir} -h {output_dir} -j {output_dir}"
    print(fastp_cmd)
    os.system(fastp_cmd)


# The idea is to get a multiqc report for every time we do something with the reads (fastp, hisat2, etc)
def run_multiqc(output_dir):
    """
    Run multiqc on a directory
    """
    multiqc_cmd = f'multiqc {output_dir}'
    print(multiqc_cmd)
    os.system(multiqc_cmd)


# It is important to check how hisat2 is doing the mapping, in our case we don't want to bias our alligments with the knowledge of splicing regions, once
# the chimeric reads that are generated by the SPLASH protocol are not known to the genome. We also want to allow/enrich for split-read mapping.
def run_hisat2(fastq_file, output_dir, genome_index):
    """
    Run hisat2 on a fastq file
    """
    hisat2_cmd = f'hisat2 -x {genome_index} -U {fastq_file} -S {output_dir}.sam'
    print(hisat2_cmd)
    os.system(hisat2_cmd)


def generate_segemehl_index(genome_file, threads):
    """
    Generate a segemehl index
    """
    segemehl_cmd = f'segemehl.x -x {genome_file[:-6]}.idx -d {genome_file} -t {threads}'
    print(segemehl_cmd)
    os.system(segemehl_cmd)


def run_segemehl(fastq_file, genome_index, genome_file, output_dir, threads):
    """
    Run segemehl on a fastq file
    """
    segemehl_cmd = f'segemehl.x -i {genome_index} -d {} -q {fastq_file} -t {threads} > {}'
    print(segemehl_cmd)
    os.system(segemehl_cmd)


def generate_ndarray_from_mapping(mapping_file):
    """
    Generate a numpy array from a mapping file, showing pairwise interactions between segments/genomes
    """
    pass


def run_deseq2_on_ndarray(ndarray):
    """
    Run DESeq2 on a numpy array
    """
    pass

